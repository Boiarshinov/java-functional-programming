# Что не так в Java 8, часть I: каррирование против замыканий #

Перевод статьи [What's wrong in Java 8, Part I: Currying vs Closures][OriginalLink].

Существует множество ошибочных идей вокруг Java 8.
Среди них идея, что Java 8 привносит в Java замыкания.
Это не так. 
Замыкания существовали в Java с самого начала. 
Но замыкания - зло. 
И так как Java 8 шагает в сторону функционального программирования, необходимо постараться избежать замыканий в Java. 
Но Java 8 не слишком помогает нам в этом.  

Главная разница между использованием методов и функций - это момент вычисления аргументов. 
В Java можно написать метод, который будет принимать аргументы и возвращать значения. 
Является ли такой метод функцией? Вовсе нет. 
С методом нельзя сделать ничего кроме как вызвать его, что приводит к тому, что аргументы метода будут вычислены
до исполнения метода. 
Так происходит потому что аргументы в Java передаются в метод по значению.

Функции - они другие. 
С функциями можно обращаться, не исполняя их. 
Также мы имеем полный контроль над моментом вычисления аргументов. 
И если у функции несколько аргументов, то их можно вычислить в разные моменты времени. 
Этого можно добиться с помощью каррирования. 
Но сначала, давайте посмотрим, как этого можно достичь с помощью замыканий.

## Пример замыкания ##

Для функций замыкание - это возможность доступа к переменным из внешнего контекста. 
В функциональном программировании результат исполнения функции должен зависеть только от ее аргументов. 
Замыкания явно нарушают это правило.

Давайте посмотрим на пример кода, актуального для Java 5/6/7:
```java
private Integer b = 2;

List list = Arrays.asList(1, 2, 3, 4, 5);

System.out.println(calculate(list.stream(), 3).collect(toList()));

private Stream calculate(Stream stream, Integer a) {
    return stream.map(new Function() {

        @Override
        public Integer apply(Integer t) {
            return t * a + b;
        }
    });
}

public interface Function<T, U> {
  U apply(T t);
}
```
В результате выполнения данного кода, получим следующий результат:
```
[5, 8, 11, 14, 17]
```
Что является результатом отображения функции `f(x) = x * 3 + 2` на список `[1, 2, 3, 4, 5]`. 
Пока все идет хорошо.
Но подождите-ка..., могут ли `3` и `2` быть изменены на другие значения? 
Другими словами, не лучше ли применить к списку функцию `f(x, a, b) = x * a + b`?

И да, и нет. 
Нет, потому что `a` и `b` - эффективно финальные переменные, поэтому при выполнении функции они ведут 
себя как константы. 
Но, конечно же, они могут изменяться. 
То, что они объявлены финальными (неявно в Java 8 и явно в более ранних версиях), сказывается только на оптимизации 
работы компилятора. 
Компилятор совершенно не волнует, что значения переменных могут измениться. 
Он беспокоится только о том, чтобы не изменялась ссылка на объект.
Другими словами, он хочет, чтобы ссылки на объекты `a` и `b` класса `Integer` не менялись, и не заботится, что
их значения могут поменяться. 
А такое может произойти:
```java
private Integer b = 2;

private Integer getB() {
    return this.b;
}

List list = Arrays.asList(1, 2, 3, 4, 5);

System.out.println(calculator.calculate(list.stream(), new Int(3)).collect(toList()));

private Stream<Integer> calculate(Stream<Integer> stream, final Int a) {
    return stream.map(new Function<Integer, Integer>() {

        @Override
        public Integer apply(Integer t) {
            return t * a.value + getB();
        }
    });
}

static private class Int {
    public int value;

    public Int(int value) {
        this.value = value;
    }
}
```
Здесь мы использовали в качестве типа для переменной `a` вместо неизменяемого класса `Integer` 
написанный собственноручно изменяемый класс `Int`, а также написали метод для получения значения переменной `b`. 
Теперь мы моделируем функцию трех переменных, но все еще используем функцию с одним аргументом и 
два замыкания вместо двух других аргументов. 
Это совсем не функционально, потому что нарушает правило независимости результата от внешнего контекста.  

Первый недостаток такого подхода заключается в том, что мы не можем использовать функцию где-либо еще, так
как она зависит не только от аргументов, но и от контекста. 
Нам придется дублировать код. 
Второй недостаток - мы не сможем изолировано протестировать нашу функцию, так как нам нужен контекст для ее исполнения.

Должны ли мы использовать функцию трех аргументов? Может показаться, что это невозможно. 
Так кажется, потому что все три аргумента вычисляются в разных местах. 
Мы могли бы написать функцию трех аргументов, но метод `map()` интерфейса `Stream` принимает функцию 
лишь одного аргумента, и не существует перегрузки для трех аргументов. 
Так что другие два аргумента уже должны быть вычислены к моменту передачи функции в метод `map()`. 
Таким образом приходится предварительно вычислять два других аргумента.

Мы добиваемся этого с помощью замыканий, но в итоге получаем плохо тестируемый код, склонный к дублированию в других
частях приложения.

Использование синтаксиса Java 8 никак не решает данную проблему:
```java
private Integer b = 2;

private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    return stream.map(t -> t * a + b);
}
```  
Что нам нужно, так это способ вычислять все три аргумента функции в различное время. Это называется каррированием
по имени Хаскелла Карри (несмотря на то, что придумал это [Моисей Шейнфинкель][CurryingInventor]!).  

## Использование каррирования ##

Каррирование - это способ обработки аргументов функции одного за другим, с получением на каждом шаге новой 
функции одного аргумента. 
К примеру, если мы имеем следующую функцию:
```
f(x, y, z) = x * y + z
``` 
мы можем вычислить ее с аргументами `3, 4, 5` и получить
```
f(3, 4, 5) = 3 * 4 + 5 = 17
``` 
Также мы можем вычислить ее только с одним аргументом `3` и получить другую функцию:
```
f(3, y, z) = g(y, z) = 3 * y + z
``` 
Теперь у нас есть новая функция `g`, принимающая только два аргумента. 
Мы можем каррировать эту функцию снова, подставив `4` вместо `y`:
```
g(4, z) = h(z) = 3 * 4 + z
``` 
Порядок, в котором мы подставляем аргументы, не важен. 
Мы не выполняем никаких вычислений. 
(Необходимо соблюдать приоритет операторов). 
Мы получаем частичное представление функции.

Как мы можем сделать такое в Java? Вот как можно провернуть такое в Java 5/6/7:
```java
private static List<Integer> calculate(List<Integer> list, Integer a) {
    return list.map(new Function<Integer, Function<Integer, Function<Integer, Integer>>>() {

        @Override
        public Function<Integer, Function<Integer, Integer>> apply(final Integer x) {
            return new Function<Integer, Function<Integer, Integer>>() {

                @Override
                public Function<Integer, Integer> apply(final Integer y) {
                    return new Function<Integer, Integer>() {

                        @Override
                        public Integer apply(Integer t) {
                            return x + y * t;
                        }
                    };
                }
            };
        }
    }.apply(b).apply(a));
}
```
Этот код выполняет поставленную задачу, но я сомневаюсь, что можно убедить разработчиков писать код в таком стиле.
К счастью, синтаксис Java 8 может помочь нам:
```java
private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    return stream.map(((Function<Integer, Function<Integer, Function<Integer, Integer>>>)
                            x -> y -> t -> x + y * t).apply(b).apply(a));
}
```
Не нравится? Разве это не должно выглядеть проще:
```java
private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    return stream.map((x -> y -> t -> x + y * t).apply(b).apply(a));
}
```
Да, должно, но Java 8 не может самостоятельно вывести типы, поэтому нам необходимо помочь ей с помощью
явного упоминания типов аргументов (в официальной документации используется термин "manifest"). 
Для того чтобы сделать код немного чище, мы можем использовать несколько приемов:
```java
interface F3 extends Function<Integer, Function<Integer, Function<Integer, Integer>>> {}

private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    return stream.map(((F3) x -> y -> z -> x + y * z).apply(b).apply(a));
}
```
Теперь мы можем присвоить нашей функции имя и использовать ее по необходимости:
```java
private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    F3 calculation = x -> y -> z -> x + y * z;
    return stream.map(calculation.apply(b).apply(a));
}
```
Мы даже можем объявить функцию как статическое поле вспомогательного класса и использовать статический импорт, 
чтобы сделать код еще чище:
```java
public class Functions {
    static Function<Integer, Function<Integer, Function<Integer, Integer>>> calculation =
        x -> y -> z -> x + y * z;
}

//...

import static Functions.calculation;

private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
  return stream.map(calculation.apply(b).apply(a));
}
```
К сожалению, Java 8 поощряет использование замыканий. 
На мой взгляд было бы намного лучше, если бы Java 8 предлагала бы синтаксический сахар для описания каррирования. 
К примеру на Scala пример выше можно написать так:
```scala
stream.map(calculation(b)(a))
```
Но в Java такой возможности нет. 
Однако мы можем приблизиться к примеру на Scala, объявив статический метод:
```java
static Function<Integer, Function<Integer, Function<Integer, Integer>>> calculation
    = x -> y -> z -> x + y * z;

static Function<Integer, Integer> calculation(Integer x, Integer y) {
    return calculation.apply(x).apply(y);
}
``` 
Теперь можно записать:
```java
private Stream<Integer> calculate(Stream<Integer> stream, Integer a) {
    return stream.map(calculation(b, a));
}
``` 
Заметьте, что `calculation(b, a)` это не функция двух аргументов. 
Это всего лишь метод, возвращающий функцию одного аргумента, которая была получена путем последовательной 
подстановки двух аргументов в функцию трех аргументов. 
В результате была получена функция одного аргумента, которую можно использовать в методе `map()`.

Метод `calculation()` теперь можно протестировать изолировано.

## Автоматическое каррирование ##

В предыдущем примере мы применяли каррирование вручную. 
Но мы можем его автоматизировать, написав метод, который будет принимать функцию двух аргументов и возвращать 
ее каррированную версию.
Это очень просто:
```java
public <A, B, C> Function<A, Function<B, C>> curry(final BiFunction<A, B, C> f) {
    return (A a) -> (B b) -> f.apply(a, b);
}
```
Если необходимо, мы можем написать обратный метод. 
Он будет принимать функцию одного аргумента `A`, возвращающую еще одну функцию одного аргумента `B` 
c типом возвращаемого значения `C`. 
А возвращать будет функцию двух аргументов `A` и `B` c типом возвращаемого значения `C`:
```java
public <A, B, C> BiFunction<A, B, C> uncurry(Function<A, Function<B, C>> f) {
    return (A a, B b) -> f.apply(a).apply(b);
}
```

## Другие области применения каррирования ##

Существуют и другие области использования каррирования. 
Одна из самых важных - моделирование функций более чем одного аргумента. 
В Java 8 существуют функции одного аргумента (`java.util.functions.Function`) и функции двух аргументов
(`java.util.functions.BiFunction`). 
Но нет функций трех, четырех, пяти или большего количества аргументов, как в некоторых других функциональных языках. 
Но они и не нужны. 
Все они были бы просто синтаксическим сахаром для случаев, когда все аргументы вычисляются одновременно. 
И на самом деле, это причина, почему `BiFunction` существует в Java 8: одно из частых применений 
функций - моделирование бинарных операторов.
(Примечание: в Java 8 существует интерфейс `BinaryOperator`, но он используется в очень редких случаях, когда оба 
аргумента и возвращаемое значение имеют одинаковый тип. Мы поговорим о нем в следующей статье).

Каррирование очень полезно, когда аргументы функции должны быть вычислены в различных местах. 
Используя каррирование, можно вычислить один аргумент в одном компоненте, затем передать результат в другой компонент,
для того чтобы вычислить другой аргумент, и так до тех пор, пока все аргументы не получат значения.

## Заключение ##

Java 8 очень далека от того, чтобы стать функциональным языком (и возможно никогда не станет). 
Однако существует возможность писать код на Java (даже в версиях ниже восьмой), используя функциональную парадигму. 
Но это будет иметь свою цену. 
Эта цена уменьшена в Java 8. 
Однако разработчики, которые хотят писать функциональный код, столкнутся с тем, что, для того чтобы оставаться в 
рамках функциональной парадигмы, необходимо подключать дополнительные интеллектуальные усилия. 
Одним из таких усилий является использование каррирования.   

Запомните:
```java
(A, B, C) -> D
```
всегда можно заменить на
```java
A -> B -> C -> D
```
даже если Java 8 не способна самостоятельно вывести типы аргументов этого выражения. 
Вам просто нужно указать эти типы в явном виде. 
Это называется каррированием, и его использование всегда будет безопаснее, чем использование замыканий.

В [следующей статье][Wrong-2-Ru] мы поговорим о функциональных интерфейсах в Java 8 и о том, как обращаться 
с примитивными типами. 



[OriginalLink]: https://dzone.com/articles/whats-wrong-java-8-currying-vs
[CurryingInventor]: https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B9%D0%BD%D1%84%D0%B8%D0%BD%D0%BA%D0%B5%D0%BB%D1%8C,_%D0%9C%D0%BE%D0%B8%D1%81%D0%B5%D0%B9_%D0%AD%D0%BB%D1%8C%D0%B5%D0%B2%D0%B8%D1%87
[Wrong-2-Ru]: Wrong_in_Java_8_Part_2.md
