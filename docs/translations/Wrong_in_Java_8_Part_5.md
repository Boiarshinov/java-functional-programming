# Что не так в Java 8, часть V: Кортежи #

Перевод статьи [What's wrong in Java 8, Part V: Tuples][OriginalLink].

Когда разработчику необходимо вернуть из метода несколько значений, он начинает замечать, что
ему не хватает кортежей.
Как все мы знаем, в Java методы могут принимать столько аргументов, сколько необходимо, но 
возвращают они всего одно значение.
В функциональных языках дело обстоит немного иначе.
Функции могут принимать только один аргумент и возвращают только одно значение, но и аргумент, 
и возвращаемое значение могут быть кортежами.


## Что такое кортеж ##

На первый взгляд кортежи похожи на упорядоченные коллекции со значениями различных типов.
Это отличает их от массивов и списков, которые могут содержать в себе элементы только одного типа.
Большинство часто используемых кортежей имеют конкретные названия:
кортеж из двух элементов называется _парой_ - _pair_ (или _double_, _couple_, _dual_, _twin_), 
а кортеж из трех элементов называется _тройкой_ - _triple_.
Также существуют названия _четверка_ - _quadruple_, _пятерка_ - _quintuple_ и так далее.
Заметьте, что также существуют кортежи для 0 и 1 элементов.
Кортеж одного элемента используется достаточно редко, так как вместо него может быть использован
сам элемент.
Однако для теоретических рассуждений мы будем использовать такие кортежи.
Кортеж одного элемента называют _одиночка_ - _single_.
~~Класс Optional в Java 8 по сути является кортежем одного элемента.~~
Также иногда употребляется название кортеж<sub>n</sub>, где _n_ - это количество элементов.

В языках программирования кортежи обычно обозначаются круглыми скобками:
```
(3, 5)
```
это кортеж из двух целых чисел, а
```
("age", 42)
```
это кортеж, состоящий из одной строки и одного целого числа.


## Существуют ли кортежи в Java ##

Без всяких сомнений, в Java существуют кортежи.
Они бывают явными и неявными.
Неявные кортежи - это совокупность аргументов методов, принимающих несколько аргументов:
```java
int mult(int x, int y) {
  return x * y;
}
int z = mult(3, 5);
``` 
В этом примере `(3, 5)` можно представить как кортеж и таким образом можно считать метод `mult` 
методом одного аргумента!

Это важно, когда мы говорим о функциях.
Функция - это преобразование одного множества (области определения функции - _domain_) 
в другое множество (область значений функции - _codomain_).

Важно отметить, что область значений - это ОДНО множество. 
Она не может быть представлена ни двумя, ни тремя множествами, ни чем-либо еще.
Она может быть представлена многомерным множеством, т.е. кортежем кортежей!
Но даже в этом случае функция имеет всего один аргумент.

Существование функций с двумя и большим количеством аргументов является всего лишь синтаксическим 
сахаром для функций с кортежами парами, тройками и пр.
Лямбда-выражение, похожее на функцию двух аргументов
```java
(int x, int y) -> x * y
``` 
является функциональным представлением приведения `int * int` (декартового произведения) к `int`.   
И результатом декартова произведения `int * int` является одиночное множество кортежей.

Теперь понятно, что в Java существуют кортежи, но мы можем использовать их только в качестве 
аргументов функции, но не в качестве возвращаемых значений.

Примечание - в Java функции двух аргументов не всегда являются синтаксическим сахаром 
для описания функций кортежей.
Также они могут использоваться для каррирования.
Это связано с моментом времени вычисления аргументов.
Подробнее об этом в [первой статье][Wrong-1-Ru] серии.


## Создание собственных кортежей ##

Когда нам необходимо вернуть кортеж, достаточно просто его создать.
К примеру, если нам нужно создать функцию преобразования _double_ в _(int, double)_, принимающую
`double` в качестве аргумента, и возвращающую его целую и дробную части, мы можем написать:
```java
public class TupleExample {

  public static class Tuple {

    public final int integerPart;
    public final double decimalPart;

    public Tuple(int integerPart, double decimalPart) {
      super();
      this.integerPart = integerPart;
      this.decimalPart = decimalPart;
    }

    @Override
    public String toString() {
      return String.format("(%s, %s)", integerPart, decimalPart);
    }
  }

  private static Tuple split(Double x) {
    int integerPart = x.intValue();
    return new Tuple(integerPart, x - integerPart);
  }

  public static void main(String[] args) {
    System.out.println(split(5.3));
    System.out.println(split(-2.7));
  }
}
```
В консоль будет выведено:
```java
(5, 0.2999999999999998)
(-2, -0.7000000000000002)
```
Теперь понятно, что большинство объектов в Java по сути являются кортежами!

Конечно, можно написать обобщенный класс для кортежей, и сделать это достаточно просто 
(некоторые методы, такие как `equals` и `hashcode` не приведены):
```java
public class TupleGenericExample {

  private static Tuple<Integer, Double> split(Double x) {
    int integerPart = x.intValue();
    return new Tuple<>(integerPart, x - integerPart);
  }

  public static void main(String[] args) {
    System.out.println(split(5.3));
    System.out.println(split(-2.7));
  }
}

public static class Tuple<T, U> {

  public final T t;
  public final U u;

  public Tuple(T arg1, U arg2) {
    super();
    this.t = arg1;
    this.u = arg2;
  }

  @Override
  public String toString() {
    return String.format("(%s, %s)", t, u);
  }
}
```
Если реализовать кортежи так просто, то в чем проблема?
Проблем здесь много:
- Мы можем написать собственные кортежи, но мы не можем использовать их в публичном API.
Чтобы это стало возможным, необходимо чтобы все Java-разработчики договорились об одинаковой 
реализации класса `Tuple`.
Такого не случится, только если реализация `Tuple` не будет добавлена в стандартную библиотеку Java.
Конечно, нам могут также понадобиться `Tuple3`, `Tuple4` и прочие кортежи с небольшим количеством
элементов.
(Существует возможность использовать `Tuple` для передачи значений в количестве больше 2, для
этого необходимо обернуть один кортеж в другой: `Tuple<T, Tuple<U, V>>`, но это не слишком
практично.)
- Мы не можем проверить тип кортежа с помощью ключевого слова `instanceof`.
То есть если мы захотим проверить объект на принадлежность к кортежу определенного типа,
нам придется проверять на соответствие каждое его поле, таким образом количество проверок будет
пропорционально количеству элементов в кортеже.
- Чтобы упростить использование `Tuple` нам нужен тот же синтаксический сахар, что и 
для аргументов в записи лямбда-выражений.
- И, конечно же, вездесущая проблема примитивных типов.
Ограничившись только 4 примитивными типами (`int`, `long`, `double`, `boolean`), мы получим
25 различных видов пар (с учетом объектов), 125 различных видов троек и так далее.
Хотя мы можем переложить ответственность на автоупаковку/распаковку.

В текущей ситуации мы можем использовать кортежи только внутри своего кода.
Мы можем создать кортежи для нужных нам примитивов, или можем пользоваться соответствующими 
классами-обертками и положиться на автоупаковку/распаковку, если производительность не
имеет существенного значения.

_Примечание переводчика_ - в стандартной библиотеке Java 8 можно было найти кортежеподобный 
класс `Pair<K, V>`, но он относился к пакету `javafx.util` 
и был исключен из стандартной библиотеки в Java 11.

## Что дальше? ##

В [следующей статье][Wrong-6-Ru] мы поговорим более детально о различиях между функциями нескольких аргументов
(которые на самом деле являются функциями кортежей) и функциями функций.

_Примечание переводчика_ - существует библиотека [javatuples][JavaTuples], 
в которой определены кортежы с количеством элементов от одного до десяти. 
Все кортежи в библиотеке типобезопасны, сериализуемы, неизменяемы и реализуют интерфейс `Comparable`.

[OriginalLink]: https://dzone.com/articles/whats-wrong-java-8-part-v
[Wrong-1-Ru]: Wrong_in_Java_8_Part_1.md
[Wrong-6-Ru]: Wrong_in_Java_8_Part_6.md
[JavaTuples]: https://www.javatuples.org
