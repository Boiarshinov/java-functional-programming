# Что не так в Java 8, часть III: Стримы и параллельные стримы #

Перевод статьи [What's wrong in Java 8, Part III: Streams and Parallel Streams][OriginalLink].

При появлении в раннем доступе Java 8 казалось, что самым главным нововведением являются
лямбда-выражения.
Сейчас большинство Java-разработчиков считают, что самой главной фичей Java 8 - это стримы.
В основном, потому что они считают, что, поменяв одно слово в своей программе (`stream` на 
`parallelStream`), их программы распараллелятся.
Многие евангелисты Java 8 демонстрируют впечатляющие примеры параллелизации с помощью стримов.
Есть ли в этом что-то неправильное?
Много чего:
- Параллельное выполнение стримов может принести выигрыш производительности, а может и не принести.
Это зависит от конкретной ситуации.
- Благодаря параллельным стримам ваши программы работают быстрее. Или нет. Или даже медленнее.
- Думая о стримах, как о способе распараллеливания вычислений малой ценой, многие разработчики
не пытаются разобраться в том, как это распараллеливание производится. 
Стримы и параллельное вычисления не связаны напрямую. 
- Большинство проблем, описанных выше, возникают из-за недопонимания: параллельные вычисления - это
не то же самое, что конкурентные вычисления. И большинство примеров "автоматической параллелизации"
в Java 8 на самом деле примеры конкурентных вычислений.
- Думать о `map`, `filter` и других промежуточных операциях, как о внутреннем итерировании - 
неверно (хотя тут проблема скорее в том как мы пользуемся стримами, а не в Java 8).

## Так что такое стримы ##

Согласно [Википедии][WikiStream] (в русскоязычной Википедии отсутствует статья о стримах):

"стрим - это потенциально бесконечный аналог списка, заданный коиндуктивным определением:
```
data Stream a = Nil | Cons a (Stream a)
```
Создание и вычисление стримов требует ленивых вычислений, либо неявно на ленивых языках, 
либо при помощи создания и использования преобразователей (thunk) в жадных языках.
В строгих функциональных языках они должны быть определены как коданные и могут быть
итерированы с помощью использования корекурсии."

Важно отметить, что Java относится к языкам программирования, которые Википедия называет "жадными",
что означает, что Java вычисляет выражения сразу (а не лениво).
Например, если вы создаете `List` в Java все элементы будут вычислены при его создании.
Это может удивить вас, потому что вы можете создать пустой список и добавить в него элементы позже.
Так можно сделать только потому что списки - изменяемы (и вы заменяете ссылки на null ссылками на
объекты или создаете новый список из старого, добавляя к нему новый элемент).

Списки создаются из чего-либо, продуцирующего их элементы. К примеру:
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
```
Здесь поставщиком является массив, и все элементы этого массива вычислены жадно.

Также возможно создать список рекурсивно, например список из 5 элементов, начинающийся с 1 
и с каждым последующим элементом больше предыдущего на единицу. 
В версиях Java ниже 8 это запишется так:
```java
List<Integer> list = new ArrayList<Integer>();
for(int i = 1; i < 6; i++) {
    list.add(i);
}
```
Кто-то может возразить, что цикл `for` это один из редких примеров ленивых вычислений в Java, 
но в результате мы получаем список, в котором все элементы вычислены.

Что будет, если мы захотим применить функцию ко всем элементам списка?
Мы можем сделать это в цикле.
Например, если мы хотим увеличить значение каждого элемента в 2 раза, мы можем сделать это так:
```java
for(int i = 0; i < list.size(); i++) {
    list.set(i, list.get(i) * 2);
}
```
Однако в таком случае мы не можем использовать операции, которые меняют тип элементов, например
операции, преобразующие `Integer` в `Double`. 
Приведенное ниже решение помогает с этой проблемой:
```java
List<Double> list2 = new ArrayList<Double>();
for(int i = 0; i < list.size(); i++) {
    list2.add(list.get(i) * 1.2);
}
```
Этот пример мы можем переписать с использованием появившегося в Java 5 синтаксиса `for each`:
```java
List<Double> list2 = new ArrayList<>();
for(Integer i : list) {
    list2.add(i * 1.2);
}
```
или с помощью синтаксиса Java 8:
```java
List<Double> list2 = new ArrayList<>();
list.forEach(x -> list2.add(x * 1.2));
```
Неплохо.
Но что если мы хотим увеличить значение на 20%, а затем разделить на 3?
Тривиальным решением будет:
```java
List<Double> list2 = new ArrayList<>();
list.forEach(x -> list2.add(x * 1.2));
List<Double> list3 = new ArrayList<>();
list2.forEach(x -> list3.add(x / 3));
```
Такое решение далеко от оптимального, потому что нам приходится дважды итерировать список.
Гораздо лучше такое решение:
```java
List<Double> list2 = new ArrayList<>();
for(Integer i : list) {
    list2.add(i * 1.2 / 3);
}
```
Давайте сейчас не вспоминать о проблеме автоупаковки/распаковки.
В Java 8 мы сможем записать это так:
```java
List<Double> list2 = new ArrayList<>();
list.forEach(x -> list2.add(x * 1.2 / 3));
``` 
Но подождите... Это возможно только благодаря тому, что нам известны операции, содержащиеся
внутри потребителей (`Consumer`), связываемых со списком. И потому мы можем вручную объединить
операции.
Если бы вместо операций в явном виде у нас были бы потребители:
```java
List<Double> list2 = new ArrayList<>();
list.forEach(consumer1);
List<Double> list3 = new ArrayList<>();
list2.forEach(consumer2);
``` 
Как мы узнали бы в каком порядке их сочетать? 
Никак.
В Java 8 функциональный интерфейс `Consumer` имеет дефолтный метод `andThen`.
Мы можем попробовать объединить потребителей следующим образом:
```java
list.forEach(consumer1.andThen(consumer2));
```
но это приведет к ошибке, потому что `andThen` определен как:
```java
default Consumer<T> andThen(Consumer<? super T> after) {
    Objects.requireNonNull(after);
    return (T t) -> { accept(t); after.accept(t); };
}
```
Это означает, что мы не можем использовать `andThen` для объединения потребителей, параметризованных
различными типами.

Проблема в том, что мы делаем все неправильно с самого начала.
Нам требуется связать список с функцией, чтобы получить новый список. Что-то вроде этого:
```java
Function<Integer, Double> function1 = x -> x * 1.2;
Function<Double, Double> function2 = x -> x / 3;
list.bind(function1).bind(function2);
```
где метод `bind` может быть определен в специальном классе `FList`, например так:
```java
public class FList<T> {
    final List<T> list;

    public FList(List<T> list) {
        this.list = list;
    }

    public <U> FList<U> bind(Function<T, U> f) {
        List<U> newList = new ArrayList<U>();
        for (T t : list) {
            newList.add(f.apply(t));
        }
        return new FList<U>(newList);
    }
}
```
и мы могли бы использовать его как в примере ниже:
```java
new Flist<>(list).bind(function1).bind(function2);
```
Единственная проблема здесь в том, что, для того чтобы связать список с двумя функциями, нам
приходится итерировать список дважды.
Так происходит потому что метод `bind` выполняется жадно.
Нам нужны ленивые вычисления, чтобы итерировать список всего один раз.

Проблема данного примера заключается в том, что метод `bind` не осуществляет настоящего связывания.
Здесь он объединяет в себе связывание и свертку (reduce). 
Свертка применяет функцию к каждому элементу списка, и комбинирует данный элемент с результатом 
выполнения функции над предыдущим элементом списка.
Для первого элемента результат вычисления комбинируется с начальным значением.
Например, комбинирующая функция `(x) -> r + x`, где `r` - результат выполнения операции над 
предыдущими элементами, и 0 для первого элемента, возвращает сумму всех элементов списка.
Применение комбинирующей функции `() -> r + 1` к каждому элементу с `r = 0` для первого элемента 
возвращает длину списка.
(Возможно это не самый эффективный способ определения длины списка, но он полностью функциональный!).

В нашем примере `add(element)` - это комбинирующая функция, а начальное значение - пустой список.
Двойное итерирование происходит, из-за того что свертка осуществляется жадно.

Java 8 предоставляет нам то же самое, но с отложенным (ленивым) выполнением, что означает, что
при связывании стрима с функцией **итерирования не происходит**!   

Связывание `Function<T, U>` с `Stream<T>` возвращает `Stream<U>` без проведения итерирования.
Возвращенный стрим не вычислен, и это не зависит от того, был ли исходный стрим создан из
вычисленных или не вычисленных данных.

В функциональных языках связывание `Function<T, U>` с `Stream<T>` само по себе является функцией.
В Java 8 это метод, что означает, что его аргументы вычисляются жадно, но это не влияет на момент
вычисления самого стрима.
Для понимания можно представить, что связывающие функции сохраняются где-то и 
становятся частью обработчика данных результирующего стрима.

В Java 8 метод, связывающий функцию `T -> U` с `Stream<T>` и возвращающий `Stream<U>`, называется
`map`. 
Метод, связывающий функцию `T -> Stream<U>` с `Stream<T>` и возвращающий `Stream<U>`, называется
`flatMap`. 

## А где же `flatten`? ##

В большинстве функциональных языков существует функция `flatten`, преобразующая `Stream<Stream<U>>`
в `Stream<U>`, но она отсутствует в Java Stream API.
В этом нет большой проблемы, потому что написать метод с таким функционалом достаточно просто. 
Например, для такой функции:
```java
Function<Integer, Stream<Integer>> f = x -> Stream.iterate(1, y -> y + 1).limit(x);

Stream<Integer> stream = Stream.iterate(1, x -> x + 1);
Stream<Integer> stream2 = stream.limit(5).flatMap(f);

System.out.println(stream2.collect(toList()))
```
получим
```java
[1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]
```
Используя метод `map` вместо `flatMap`:
```java
Stream<Integer> stream = Stream.iterate(1, x -> x + 1);
Stream<Integer> stream2 = stream.limit(5).map(f);

System.out.println(stream2.collect(toList()))
```
получим стрим стримов:
```
[java.util.stream.SliceOps$1@12133b1, java.util.stream.SliceOps$1@ea2f77,
java.util.stream.SliceOps$1@1c7353a, java.util.stream.SliceOps$1@1a9515, 
java.util.stream.SliceOps$1@f49f1c]
```
Преобразовать этот стрим стримов целых чисел в стрим целых чисел очень просто с использованием
функциональной парадигмы: нужно вызвать `flatMap` с тождественным отображением (identity function):
```java
System.out.println(stream2.flatMap(x -> x).collect(toList()));
```
Очень странно, что метод `flatten` не был добавлен в API `Stream`, учитывая тесную связанность между
`map`, `flatMap`, `unit` и `flatten`, где функция `unit`, преобразующая `T` в `Stream<T>`, 
представлена методом  
```java
Stream<T> Stream.of(T... t)
```

## Когда стримы вычисляются? ##

Стримы вычисляются, когда мы применяем к ним операции, называемые терминальными.
Они могут быть вызваны только один раз.
После того как на стриме вызвана терминальная операция, его больше невозможно использовать.
Ниже приведен список терминальных операций:
- `forEach`
- `forEachOrdered` 
- `toArray` 
- `reduce` 
- `collect` 
- `min` 
- `max` 
- `count` 
- `anyMatch` 
- `allMatch` 
- `noneMatch` 
- `findFirst` 
- `findAny` 
- `iterator` 
- `spliterator`

Некоторые из этих методов - короткозамкнутые (short circuiting). К примеру `findFirst` вернет первый
найденный элемент, не вычисляя остальных.

Нетерминальные операции называются промежуточными и могут быть зависимыми от состояния - stateful 
(если вычисление элемента зависит от результата вычисления предыдущего) или независимыми - stateless.
Промежуточными операциями являются:
- `filter`
- `map`
- `mapTo...` (`Int`, `Long` or `Double`)
- `flatMap`
- `flatMapTo...` (`Int`, `Long` or `Double`)
- `distinct`
- `sorted`
- `peek`
- `limit`
- `skip`
- `sequential`
- `parallel`
- `unordered`
- `onClose`

К стриму может быть применено несколько промежуточных операций и только одна терминальная.

## Так что с параллельными вычислениями? ##

Одна из широко разлекрамированных возможностей стримов - это автоматическое распараллеливание 
вычислений.
Каждый может найти в интернете впечатляющие примеры, основанные чаще всего на обращении к удаленному
серверу. 
Такие примеры могут показывать увеличение производительности на 400% и более.

Но эти примеры имеют мало общего с параллельными вычислениями.
Это примеры конкурентных вычислений, что означает, что увеличение скорости будет наблюдаться
даже на одноядерных процессорах.
Так происходит, потому что большую часть времени распараллеленные задачи находятся в ожидании.
Параллельные же вычисления нужны для выполнения задач, которые не должны простаивать, например,
сложные расчеты. 

Автоматическое распараллеливание не дает ожидаемых результатов в основном по двум причинам:
1. Увеличение производительности сильно зависит от типа задачи и стратегии распараллеливания.
Какая стратегия является самой выгодной, зависит от типа задачи.
2. Увеличение производительности сильно зависит от окружения. В некоторых случаях очень просто
получить снижение производительности при попытке распараллеливания.

Стратегия распараллеливания стримов всегда одинакова, вне зависимости от типа задач.
Распараллеливание требует:
- Пул нитей для выполнения подзадач;
- Разделение основной задачи на подзадачи;
- Распределение задач по нитям; 
- Объединение результатов.

Все это требует дополнительных вычислительных затрат.
Невероятные приросты скорости могут наблюдаться только когда:
- Некоторые задачи простаивают в течение долгого времени, например при обращении к удаленному 
сервису, или
- Одновременно выполняется небольшое количество нитей, при этом в то же время не вычисляются
другие параллельные стримы. 

Если все подзадачи требуют значительных вычислений, потенциальный выигрыш производительности 
ограничен количеством доступных ядер процессора.
Java 8 по умолчанию использует столько нитей, сколько ядер у процессора, так что для ресурсоемких
задач выигрыш производительности зависит от количества нитей, запущенных одновременно.
Конечно, если каждая подзадача заключается в ожидании ответа от удаленного сервиса, то
выигрыш производительности может быть ощутимым.

В худшем же случае, приложение может быть запущено на сервере или в контейнере вместе с другими 
приложениями, а подзадачи не будут большую часть времени находиться в ожидании.
В таком случае (например, при работе на J2EE сервере) параллельные стримы часто будут работать
медленнее, чем последовательные.
Представьте, что сервер обрабатывает сотни запросов каждую секунду.
Шанс того, что несколько стримов будут вычисляться одновременно - огромен, так что приложение
уже распараллелено. 
Новый слой параллелизации на уровне бизнес-логики скорее всего замедлит работу приложения.

Что хуже всего: вполне возможно, что приложения будут показывать увеличение производительности
на стенде разработчиков, но будут работать медленнее в продакшене.
И это худшее, что может быть.

Для понимания недостатков параллельных стримов в Java 8 (и Fork/Join пулов в Java 7), 
обратитесь к великолепным статьям авторства Edward Harned:
- [A Java Fork-Join Calamity][ForkJoin]
- [A Java Parallel Calamity][ParallelCalamity]

## Где стримы хороши ##

Стримы - полезный инструмент, потому что они предоставляют возможности ленивых вычислений.
Это очень важно с нескольких сторон:
- Они позволяют писать код в функциональном стиле с использованием связывания.
- Они позволяют увеличить производительность за счет отсутствия лишнего итерирования.
Итерирование производится во время вычислений.
С помощью стримов мы можем привязать к списку несколько функций, **не итерируя** его.
- Они обеспечивают простое распараллеливание для задач, которые включают в себя долгое ожидание.
- Стримы могут быть бесконечными (потому что они ленивые). 
Функции могут быть без проблем связаны с бесконечными стримами.
При вычислении должна быть применена операция, которая сделает стрим конечным.
Зачастую это делается с помощью короткозамкнутых операций.

## Где стримы плохи ##

В случае ресурсоемких задач использовать стримы следует с большой осторожностью.
По-умолчанию все стримы используют один `ForkJoinPool`, в котором количество нитей соответствует
количеству ядер процессора, где запущено приложение.

При выполнении параллельного стрима его задачи будут разбиты на столько подзадач, сколько существует
нитей в пуле.
Другие параллельные стримы не смогут выполняться, потому что все нити уже заняты.
Для того чтобы не блокировать другие стримы, следует при вычислении стримов с ресурсоемкими задачами
использовать отдельные `ForkJoinPool`.

Для этого необходимо создать `Callable` из стрима и передать его в пул:
```java
List<SomeClass> list = // A list of objects
Stream<SomeClass> stream = list.parallelStream().map(this::veryLongProcessing);
Callable<List<Integer>> task = () -> stream.collect(toList());
ForkJoinPool forkJoinPool = new ForkJoinPool(4);
List<SomeClass> newList = forkJoinPool.submit(task).get()
```  
Таким образом другие стримы (использующие свои собственные `ForkJoinPool`) не будут блокироваться 
данным.
Другими словами, нам нужен пул из `ForkJoinPool`, чтобы справиться с проблемой.

Если ваше приложение выполняется внутри контейнера, то будьте очень внимательны при использовании
параллельных стримов.
Никогда не используйте стандартный пул нитей, кроме ситуаций, когда вы уверены, что это не скажется
на производительности.
В Java EE контейнере не используйте параллельные стримы вовсе.



[OriginalLink]: https://dzone.com/articles/whats-wrong-java-8-part-iii
[WikiStream]: https://en.wikipedia.org/wiki/Stream_(computer_science)
[ForkJoin]: http://www.coopsoft.com/ar/CalamityArticle.html
[ParallelCalamity]: http://www.coopsoft.com/ar/Calamity2Article.html
